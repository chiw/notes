<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Java always pass-by-value # https://www.cs.virginia.edu/~jh2jf/courses/cs2110/java-pass-by-value.html primitive type, variable values stored in stack memory object, copy the object reference in stack memory break vs continue # break: jump out of a loop continue: break one iteration, continue to next iteration Serialization vs deserialization # Serialization: convert Object to byte stream Deserialization: convert byte stream to Object
Private constructor # to restrict object creation. if constructor is declared as private, then its object are only accessible from within the declared class."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Core Java"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://your-github-username.github.io/docs/corejava/"><title>Core Java | Notes</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.de6b93040391b59a15d1b286db32fcd93d16a1c0dfd9c2769097745a4c97c31b.css integrity="sha256-3muTBAORtZoV0bKG2zL82T0WocDf2cJ2kJd0WkyXwxs=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.f8d75a985fad78d68e8a9c7da3fa1fd4d41d9a5863f90f26ff0495228fa30874.js integrity="sha256-+NdamF+teNaOipx9o/of1NQdmlhj+Q8m/wSVIo+jCHQ=" crossorigin=anonymous></script>
<link rel=alternate type=application/rss+xml href=https://your-github-username.github.io/docs/corejava/index.xml title=Notes></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Notes</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><a href=/docs/corejava/ class=active>Core Java</a><ul></ul></li><li class=book-section-flat><a href=/docs/gitops/>CICD / GitOps</a><ul></ul></li><li class=book-section-flat><a href=/docs/go/>Golang (goroutines & concurrency)</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Core Java</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#java-always-pass-by-value>Java always pass-by-value</a></li><li><a href=#break-vs-continue>break vs continue</a></li><li><a href=#serialization-vs-deserialization>Serialization vs deserialization</a></li><li><a href=#private-constructor>Private constructor</a></li><li><a href=#reflection>Reflection</a></li><li><a href=#unmodifiable-vs-immutable>Unmodifiable vs Immutable</a></li><li><a href=#how-to-create-immutable-class>How to create immutable class:</a></li><li><a href=#final-keyword>final keyword:</a></li><li><a href=#static-keyword>Static keyword:</a></li><li><a href=#static-nested-class-vs-inner-class-non-static>Static Nested class vs Inner Class (non static)</a></li><li><a href=#java-enumerations>Java Enumerations</a></li><li><a href=#thread-vs-executor>Thread vs Executor</a></li><li><a href=#executorservice-java6-vs-forkjoin-pool-java7>ExecutorService (Java6) vs Fork/Join Pool (Java7)</a></li><li><a href=#recursiveaction-vs-recursivetask-for-forjoinpool>RecursiveAction vs RecursiveTask (for ForJoinPool)</a></li><li><a href=#thread-states>Thread states</a></li><li><a href=#intrinsic-lock-monitor-lock-vs-extrinsic-lock>intrinsic lock (monitor lock) vs extrinsic lock</a><ul><li><a href=#intrinsic-lock>Intrinsic lock:</a></li><li><a href=#extrinsic-lock>Extrinsic lock:</a></li></ul></li><li><a href=#reentrantlock>ReentrantLock</a></li><li><a href=#lock-vs-synchronized>Lock vs Synchronized</a><ul><li><a href=#synchronzied>Synchronzied</a></li><li><a href=#lock>lock</a></li></ul></li><li><a href=#lock-implementations>Lock implementations</a><ul><li><a href=#trylock-does-not-work-with-wait--notify--notifyall><code>tryLock()</code> DOES NOT work with wait() / notify() / notifyAll()</a></li><li><a href=#countdownlatch>CountDownLatch</a></li><li><a href=#cyclicbarrier>CyclicBarrier</a></li><li><a href=#semaphore>Semaphore</a></li></ul></li><li><a href=#volatile-vs-atomic>Volatile vs Atomic</a></li><li><a href=#type-of-class-loaders>Type of class loaders</a></li><li><a href=#hashcode>hashCode()</a></li><li><a href=#data-structure-bigo>Data structure BigO</a></li><li><a href=#treemap>TreeMap:</a></li><li><a href=#queue-fifo>Queue FIFO:</a></li><li><a href=#stack-lifo>Stack LIFO:</a></li><li><a href=#completablefuture-vs-future>CompletableFuture vs Future</a></li><li><a href=#functionalinterface>FunctionalInterface</a></li><li><a href=#abstract-class-vs-interface>Abstract class vs Interface</a></li><li><a href=#polymophism-means-many-forms>Polymophism means &ldquo;many forms&rdquo;</a></li><li><a href=#method-overloading>Method overloading:</a></li><li><a href=#method-overriding>Method overriding:</a></li><li><a href=#aop>AOP</a></li><li><a href=#spring-order>Spring Order</a></li><li><a href=#jvm-heap-vs-non-heap>JVM Heap vs Non-heap</a></li><li><a href=#hibernate-1st-level-cache-vs-2nd-level-cache>Hibernate 1st level cache vs 2nd level cache</a></li><li><a href=#rxjava>RxJava</a><ul><li><a href=#how-to-handle-back-pressure>How to handle back pressure</a></li><li><a href=#rxjava-backpressured>RxJava BackPressured</a></li></ul></li><li><a href=#deadlock-can-capture-threaddump>deadlock (can capture threaddump)</a></li><li><a href=#heapdump-can-use-to-check-memory-leak>Heapdump (can use to check memory leak)</a></li><li><a href=#memory-leak>Memory leak</a></li><li><a href=#parallel-gc>Parallel GC</a></li><li><a href=#g1gc>G1GC</a><ul><li><a href=#g1gc-concepts>G1GC Concepts</a></li><li><a href=#marking-cycle>Marking Cycle:</a></li></ul></li><li><a href=#comparator>Comparator</a></li><li><a href=#project-loom-java-19>Project Loom (Java 19)</a></li></ul></nav></aside></header><article class=markdown><h2 id=java-always-pass-by-value>Java always pass-by-value
<a class=anchor href=#java-always-pass-by-value>#</a></h2><ul><li><a href=https://www.cs.virginia.edu/~jh2jf/courses/cs2110/java-pass-by-value.html>https://www.cs.virginia.edu/~jh2jf/courses/cs2110/java-pass-by-value.html</a></li><li>primitive type, variable values stored in stack memory</li><li>object, copy the object reference in stack memory</li></ul><h2 id=break-vs-continue>break vs continue
<a class=anchor href=#break-vs-continue>#</a></h2><ul><li>break: jump out of a loop</li><li>continue: break one iteration, continue to next iteration</li></ul><h2 id=serialization-vs-deserialization>Serialization vs deserialization
<a class=anchor href=#serialization-vs-deserialization>#</a></h2><p>Serialization: convert Object to byte stream
Deserialization: convert byte stream to Object</p><h2 id=private-constructor>Private constructor
<a class=anchor href=#private-constructor>#</a></h2><ul><li>to restrict object creation.</li><li>if constructor is declared as private, then its object are only accessible from within the declared class.</li><li>Cannot access its objects from outside the constructor class.</li></ul><h2 id=reflection>Reflection
<a class=anchor href=#reflection>#</a></h2><ul><li>is a feature in Java which allows an executing Java program to examine or &ldquo;introspect&rdquo; upon itself, and manipulate internal properties of the program.</li><li>support dynamic retrival and manipulation of classes and datastructures within a Java program
For example, it&rsquo;s possible for a Java class to obtain the names of all its members and display them.
Refelect can:</li><li>find methods of a class, constructors, methods, fields</li><li>invoke methods by name</li><li>create new objects</li><li>change field values</li></ul><h2 id=unmodifiable-vs-immutable>Unmodifiable vs Immutable
<a class=anchor href=#unmodifiable-vs-immutable>#</a></h2><p>// unmodifiable list - A read only view of another collection, the source collection still can be modified and will be reflected
List list2 = Collections.unmodifiableList(list1);</p><p>// immutable list - A read only copy of another collection, source collection update will not reflect to the immutable list
List list3 = Collections.unmodifiableList(new ArrayList&lt;>(list1));</p><h2 id=how-to-create-immutable-class>How to create immutable class:
<a class=anchor href=#how-to-create-immutable-class>#</a></h2><ul><li>declare the class as final, so cannot be extended</li><li>class members should be private, so cannot be accessed outside of class</li><li>no setter methods</li><li>getter method should return the copy of class members</li><li>initilized only via constructor</li></ul><h2 id=final-keyword>final keyword:
<a class=anchor href=#final-keyword>#</a></h2><ul><li>can&rsquo;t be extended or modified</li><li>final is only about the reference, but not about the contents of the referenced object</li></ul><h2 id=static-keyword>Static keyword:
<a class=anchor href=#static-keyword>#</a></h2><ul><li>static variables - a variable which belongs to the class and initilized only once at the start of execution.</li><li>static methods - a method that belongs to a class rather than an instance of a class</li><li>static block - set of instructions that runs only once when a class is loaded into memory</li><li>static nested class - nested class declared as static</li></ul><h2 id=static-nested-class-vs-inner-class-non-static>Static Nested class vs Inner Class (non static)
<a class=anchor href=#static-nested-class-vs-inner-class-non-static>#</a></h2><ul><li>Static Nest Class - Nested classes that are declared static. (Can instantiate without instantiate outer class, can access outer class private static members)</li><li>Inner class - Non-static nested classes. (Need first instantiate Outer class first, then instantiate inner class)<ul><li>sometimes inner class will also cause memory leak, as inner class object implicitly holds a reference of outer class object, making it cannot GC</li><li>so if inner class does not need to access outer class members, change to static class instead</li></ul></li></ul><h2 id=java-enumerations>Java Enumerations
<a class=anchor href=#java-enumerations>#</a></h2><ul><li>Enum is a special Java type used to define collections of constants.</li></ul><p>.valueOf(String str)
Level level = Level.valueOf(&ldquo;HIGH&rdquo;);</p><p>.name() return name of the enum
.toString() default return name, but can be overriden</p><p>EnumSet,
EnumMap</p><pre tabindex=0><code>public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
}
</code></pre><h2 id=thread-vs-executor>Thread vs Executor
<a class=anchor href=#thread-vs-executor>#</a></h2><p>Thread is used to run your code in parallel.
Executor is an interface which also provides parallel execution, but via a thread pool.</p><ul><li>allows your task to be executed by a worker thread form thread pool.</li></ul><h2 id=executorservice-java6-vs-forkjoin-pool-java7>ExecutorService (Java6) vs Fork/Join Pool (Java7)
<a class=anchor href=#executorservice-java6-vs-forkjoin-pool-java7>#</a></h2><p>Fork/Join
The fork/join an ExecutorService for running ForkJoinTasks. It is designed for work that can be broken into smaller pieces recursively.
(work-stealing algo: worker thread tries to get tasks from the head of it&rsquo;s own dequeue.
When it is empty, the thread takes a task from tail of the dequeue of another busy thread.)</p><p>Fork/Join&rsquo;s logic is very simple:</p><ol><li>separate (fork) each large task into smaller tasks (ForkJoinTask, RecursiveAction);</li><li>process each task in a separate thread (separating those into even smaller tasks if necessary);</li><li>join the results.</li></ol><h2 id=recursiveaction-vs-recursivetask-for-forjoinpool>RecursiveAction vs RecursiveTask (for ForJoinPool)
<a class=anchor href=#recursiveaction-vs-recursivetask-for-forjoinpool>#</a></h2><p>RecursiveAction: do not have return result
RecursiveTask: have return result</p><p>ExecutorService is an Executor that provides methods to manage the progress-tracking and termination of asynchronous tasks.</p><p>Runnable is an interface which represents a task that could be executed by either a Thread or Executor or some similar means.
Thread is a class which creates a new thread.</p><h2 id=thread-states>Thread states
<a class=anchor href=#thread-states>#</a></h2><ul><li><p><a href=https://javaconceptoftheday.com/difference-between-blocked-vs-waiting-states-in-java/>https://javaconceptoftheday.com/difference-between-blocked-vs-waiting-states-in-java/</a></p></li><li><p><code>NEW</code> - when a thread is newly created</p></li><li><p><code>RUNNABLE</code> - when thread.start() is triggered</p></li><li><p><code>WAITING</code> - when the wait(), join(), will remain WAITING state, will be waken up by other threads calling notify() or notifyAll()</p></li><li><p><code>TIME_WAITING</code> - waiting for another thread release the lock, up to a given time</p></li><li><p><code>BLOCKED</code> - notified by other thread, but still has not got the lock yet, waiting other thread to release the lock</p></li><li><p><code>TERMINATED</code> - thread exits</p></li></ul><h2 id=intrinsic-lock-monitor-lock-vs-extrinsic-lock>intrinsic lock (monitor lock) vs extrinsic lock
<a class=anchor href=#intrinsic-lock-monitor-lock-vs-extrinsic-lock>#</a></h2><ul><li>Lock: More fine grined and flexibility, With locks, you can release and acquire the locks in any order. - - Also Lock can have fairness.</li><li>Synchronized block: with synchronized, you can release the locks only in the order it was acquired.</li></ul><h3 id=intrinsic-lock>Intrinsic lock:
<a class=anchor href=#intrinsic-lock>#</a></h3><ul><li>In intrinsic locks, acquire-release pairs are block-structured.
In other words, a lock is always released in the same basic block in which it was acquired, regardless of how control exits the block.</li></ul><h3 id=extrinsic-lock>Extrinsic lock:
<a class=anchor href=#extrinsic-lock>#</a></h3><p>Extrinsic locks allow the facility to have more explicit control.</p><h2 id=reentrantlock>ReentrantLock
<a class=anchor href=#reentrantlock>#</a></h2><ul><li><p>allows threads to enter into the lock on a resource more than once.</p></li><li><p>When the thread 1st enter into the lock, a hold count is set to 1.</p></li><li><p>Before unlocking the thread can re-enter into lock again and everytime hold count is incremented by one.</p></li><li><p>For every unlock(), hold count is decremented by one and when hold count is 0, the resource is unlocked.</p></li><li><p>wait() -> suspend a thread, will release the lock or monitor</p></li><li><p>join() -> wait this thread to die (<a href=https://www.baeldung.com/java-thread-join>https://www.baeldung.com/java-thread-join</a>)</p></li><li><p>notify() -> wakes up a single random thread which is waiting for this object&rsquo;s monitor.</p></li><li><p>notifyAll() -> wakes up all thread which is waiting for this object&rsquo;s mointor.</p></li><li><p>sleep() -> different from wait(), change state to TIME_WAITING</p></li><li><p><a href=https://howtodoinjava.com/java/multi-threading/sleep-vs-wait/>https://howtodoinjava.com/java/multi-threading/sleep-vs-wait/</a></p></li></ul><h2 id=lock-vs-synchronized>Lock vs Synchronized
<a class=anchor href=#lock-vs-synchronized>#</a></h2><h3 id=synchronzied>Synchronzied
<a class=anchor href=#synchronzied>#</a></h3><ul><li>fully contained within a method</li><li>Not support fairness</li></ul><h3 id=lock>lock
<a class=anchor href=#lock>#</a></h3><ul><li><p>lock() and unlock() operation can be in different methods</p></li><li><p>support fairness, can config fairness property that the longest waiting thread is given access to the lock</p></li></ul><h2 id=lock-implementations>Lock implementations
<a class=anchor href=#lock-implementations>#</a></h2><ul><li><code>ReentrantLock</code></li><li><code>ReentrantReadWriteLock</code></li><li><code>StampedLock</code> - supports read and write locks, when lock, will provide a stamp which is then used to release the lock, Optimistic locking</li></ul><p>e.g.
<a href=https://www.baeldung.com/java-concurrent-locks>https://www.baeldung.com/java-concurrent-locks</a></p><pre tabindex=0><code>public class CustomSharedStack {

    Stack&lt;String&gt; stack = new Stack&lt;&gt;();
    int CAPACITY = 5;

    ReentrantLock lock = new ReentrantLock();
    Condition notEmptyCondition = lock.newCondition();
    Condition notFullCondition = lock.newCondition();

    public void pushToStack(Item item) {
        lock.lock();
        try {
            while(stack.size() == CAPACITY) {
                notFullCondition.await(); // wait for not full condition
            }

            stack.push(item);
            notEmptyCondition.signalAll(); // tell other threads not empty anymore

        } catch(InterrupttedException e) {

        } finally {
            lock.unlock();
        }
    }

    public void popFromStack() {
        lock.lock();
        try {
            while(stack.size() == 0) {
                notEmptyCondition.await(); // wait for not empty condition
            }

            return stack.pop();
            notFullCondition.signalAll(); // tell other threads not full anymore

        } finally {            
            lock.unlock();
        }
    }
}
</code></pre><h3 id=trylock-does-not-work-with-wait--notify--notifyall><code>tryLock()</code> DOES NOT work with wait() / notify() / notifyAll()
<a class=anchor href=#trylock-does-not-work-with-wait--notify--notifyall>#</a></h3><p><a href=https://stackoverflow.com/questions/52990630/using-trylock-together-with-wait-and-notify-notifyall>https://stackoverflow.com/questions/52990630/using-trylock-together-with-wait-and-notify-notifyall</a></p><p>Reason: Every object has an implicit lock. Calling wait/notify always uses the implicit lock
Solution: Use Condition
e.g. Condition notEmpty = lock.newCondition();
notEmpty.signalAll</p><p><a href=https://www.cnblogs.com/xing901022/p/8696550.html>https://www.cnblogs.com/xing901022/p/8696550.html</a>
<a href="https://www.youtube.com/watch?v=J3QZ5gfCtAg">https://www.youtube.com/watch?v=J3QZ5gfCtAg</a> &lt;- CountdownLatch / CyclicBarrier / Phaser (Phaser can be used as both countdownlatch and cyclicBarrier)</p><h3 id=countdownlatch>CountDownLatch
<a class=anchor href=#countdownlatch>#</a></h3><ul><li>Awaiting thread waiting for multiple threads (e.g. 3) to trigger countDown(). When all threads (3 threads) have called, the awaiting thread continues to execute</li><li>CountDownLatch cannot be reused</li></ul><h3 id=cyclicbarrier>CyclicBarrier
<a class=anchor href=#cyclicbarrier>#</a></h3><ul><li>when different threads (e.g. 3) wait for each other and when all have finished their execution, the results will be combined in the parent thread</li><li>CyclicBarrier can be reused</li></ul><h3 id=semaphore>Semaphore
<a class=anchor href=#semaphore>#</a></h3><ul><li>A counting semaphore. Conceptually, a semaphore maintains a set of permits.</li></ul><p><a href=https://jenkov.com/tutorials/java-concurrency/volatile.html>https://jenkov.com/tutorials/java-concurrency/volatile.html</a></p><h2 id=volatile-vs-atomic>Volatile vs Atomic
<a class=anchor href=#volatile-vs-atomic>#</a></h2><ul><li><p>volatile keyword guarantees that all reads of - a volatile variable are read directly from main memory,</p></li><li><p>and all writes to a volatile variable are written directly to main memory</p></li><li><p>but does not prevent from race conditions, e.g. 2 threads are adding 1 to the volatile counter</p><ul><li>we should use synchronized block to gaurantee the reading and writing of the variable is atomic</li><li>e.g. AtomicInteger, AtomicLong AtomicReference</li></ul></li><li><p>AtomicInteger could be slow if too many threads will cause too much CPU on AtomicInteger&rsquo;s compare and swap</p></li></ul><h2 id=type-of-class-loaders>Type of class loaders
<a class=anchor href=#type-of-class-loaders>#</a></h2><ol><li>Bootstrap class loader</li><li>Extension class loaders (extension of the standard core java classes)</li><li>System/Application class loader (loading all application level classes into JVM, loads files found in classpath env variable)</li></ol><h2 id=hashcode>hashCode()
<a class=anchor href=#hashcode>#</a></h2><pre tabindex=0><code>@Override
public int hashCode() {
    int hash = 7;
    hash = 31 * hash + (int) id;
    hash = 31 * hash + (name == null ? 0 : name.hashCode());
    hash = 31 * hash + (email == null ? 0 : email.hashCode());
    return hash;
}
</code></pre><h2 id=data-structure-bigo>Data structure BigO
<a class=anchor href=#data-structure-bigo>#</a></h2><pre tabindex=0><code>Array
Access: O(1)
Search: O(N)
Insert: O(N)
Delete: O(N)

Stack, Queue
Access: O(N)
Search: O(N)
Insert: O(1)
Delete: O(1)

LinkedList, double linked list
Access: O(n)
Search: O(n)
Insert: O(1)
Delete: O(1)
</code></pre><h2 id=treemap>TreeMap:
<a class=anchor href=#treemap>#</a></h2><p>celingKey(), floorKey(), firstKey(), lastKey(), headMap(), tailMap() &ndash;> they will return null if no such key</p><h2 id=queue-fifo>Queue FIFO:
<a class=anchor href=#queue-fifo>#</a></h2><p>Throws exception: add(), remove(), element()
return special value: offer(), poll(), peek()</p><h2 id=stack-lifo>Stack LIFO:
<a class=anchor href=#stack-lifo>#</a></h2><p>peek(), pop(), push()</p><p>Dequeue should be used instead of Stack:
Throws exception: addFirst()/removeFirst()/getFirst() addLast()/removeLast()/getLast()
return special value: offerFirst()/pollFirst()/peekFirst() offerLast()/pollLast()/peekLast()</p><p>BlockingQueue - commonly used in producer-consumer scenario:</p><ul><li>ArrayBlockingQueue - Bounded blocking queue backed by Array</li><li>LinkedBlockingQueue - Optionally bounded blocking queue backed by LinkedList</li><li>Blocking: put(e), take()</li></ul><p>producer consumer design:</p><ul><li>Create a shared queue data structure with capacity (BlockingQueue, or Queue with locks NOT_FULL, NOT_EMPTY)</li><li>If not using blocking queue, implement put() take() method</li><li>Implement Runnable for Producer which will keep running, while queue is not full, put new item to the queue</li><li>Implement Runnable for Consumer which will keep running, while queue is not empty, take first itme from queue</li><li>new 2 threads to run Producer and Consumer Runnable</li></ul><h2 id=completablefuture-vs-future>CompletableFuture vs Future
<a class=anchor href=#completablefuture-vs-future>#</a></h2><ul><li><p>CompletableFuture is used for asynchronous programming in Java,
which means writing non-blocking code by running a task on a separate thread than the main thread,
and later notify the main thread about it&rsquo;s progress (e.g. completed, failed etc)</p></li><li><p>Future provides .isDone() .get(), but does not provide any method to manually complete the result (e.g. CompletableFuture.complete())</p></li><li><p>Can complete manually (e.g. If API call is time-consuming, you are running it in a separate thread and returning a Future.
If that API service is down, you want to complete the Future manually by the last cached price of the product. Future can&rsquo;t but CompletableFuture can)</p></li><li><p>Can chain multiple futures together (thenApply, thenCompose)</p></li><li><p>Can combine multiple futures together</p></li><li><p>Have exception handling</p></li></ul><h2 id=functionalinterface>FunctionalInterface
<a class=anchor href=#functionalinterface>#</a></h2><ul><li>an interface which has Single Abstract method (unimplemented method)</li><li>can also have default methods or static methods</li><li>Main diff between abstract class: abstract classes can have constructors, state and behavior</li></ul><h2 id=abstract-class-vs-interface>Abstract class vs Interface
<a class=anchor href=#abstract-class-vs-interface>#</a></h2><p>Both of them cannot be instantiated.
Interface helps to declare the functionality, but not implementing it. (Can have default/static methods, but do not have state)
Abstract class can provide some common functionality implementation for the subclasses, allows code reusability.</p><h2 id=polymophism-means-many-forms>Polymophism means &ldquo;many forms&rdquo;
<a class=anchor href=#polymophism-means-many-forms>#</a></h2><ul><li>use the methods to perform different tasks</li><li>method overloading (same method name different params)</li><li>method overriding (child class implements the same method which already provided in parent class)</li></ul><h2 id=method-overloading>Method overloading:
<a class=anchor href=#method-overloading>#</a></h2><p>same method name, but different parameters (no of params / param type)
(Compile time polymophism)
increase readability of the program</p><h2 id=method-overriding>Method overriding:
<a class=anchor href=#method-overriding>#</a></h2><p>subclass to provide the specific implementation that is already provided by parent classes
(Run-time polymorphism)</p><p>HashMap: only allows 1 null key
ConcurrentMaps (ConcurrentHashMap, ConcurrentSkipListMap): Not allow null key (avoid ambiguous)</p><ul><li>ConcurrentHashMap.putIfAbsent() &lt;- to prevent race condition</li></ul><p>Important!!
<a href=https://books.trinket.io/thinkjava2/chapter9.html>https://books.trinket.io/thinkjava2/chapter9.html</a>
HashMap keys must be IMMUTABLE
String is immutable.
Wrapper classes are immutable (e.g. Integer, Double, Boolean, Character, Long)</p><p>Set does not allow null, does not allows duplicates</p><ul><li>Treemap does not allow null</li><li>HashSet allosw 1 null value</li></ul><p>Map does not allow duplicates, and only accept 1 null</p><h2 id=aop>AOP
<a class=anchor href=#aop>#</a></h2><p>AspectJ spring boot
<a href=https://www.baeldung.com/aspectj>https://www.baeldung.com/aspectj</a>
<a href=https://segmentfault.com/a/1190000013290504>https://segmentfault.com/a/1190000013290504</a>
<a href=https://blog.jayway.com/2007/02/16/static-mock-using-aspectj/>https://blog.jayway.com/2007/02/16/static-mock-using-aspectj/</a></p><h2 id=spring-order>Spring Order
<a class=anchor href=#spring-order>#</a></h2><ul><li>Smallest Value has highest precedence, which will run first</li><li>Highest Value has lowest precedence, which will run later</li><li>High order advice will run first</li></ul><h2 id=jvm-heap-vs-non-heap>JVM Heap vs Non-heap
<a class=anchor href=#jvm-heap-vs-non-heap>#</a></h2><p><a href=https://betterprogramming.pub/understanding-the-jvm-memory-model-heap-vs-non-heap-c14aa6fa703e>https://betterprogramming.pub/understanding-the-jvm-memory-model-heap-vs-non-heap-c14aa6fa703e</a></p><p>Heap: (Eden space, survivor space s0, s1, Old gen)
Non Heap: (Meatpspace, Stack memory, code cache)</p><p>MetaData:
Class loader loads a class, allocates memory in the metaspace for its metadata,
that memory is owned by class loader and is only released when class load itself is unloaded.</p><p>Stack memory:
LIFO, contains method that thread called that did not finish its execution, also local variables</p><ul><li>if primitive type, store entirely in stack memory</li><li>if Object, only object reference is stored, actual value is stored on the heap</li><li>memory handling faster than heap</li><li>much smaller capacity than heap</li><li>more safe than heap, can only be accessed by the thread</li></ul><p>Code cache:</p><ul><li>compiled byptecode -> machine code by JVM intepreter -> optimization during runtime by JIT compiler</li><li>optimized machine code stored under code cache</li></ul><p>GraalVM
<a href=https://dzone.com/articles/profiling-native-images-in-java>https://dzone.com/articles/profiling-native-images-in-java</a></p><p>Pros:</p><ul><li>faster startup<ul><li>no classloading - all classes have been already loaded, linked and even partially initiated.</li><li>no interpreted code</li><li>no need to start JIT compiler and JIT our code to make it performant</li></ul></li></ul><p>Cons:</p><ul><li>reflection</li><li>Only enterprise provides G1GC, otherwise serialGC, heap size</li><li>no threaddudmp, as no JVMTI</li></ul><p>Streams Optional.ofNullable:
<a href=https://stackoverflow.com/questions/17081063/how-should-we-manage-jdk8-stream-for-null-values>https://stackoverflow.com/questions/17081063/how-should-we-manage-jdk8-stream-for-null-values</a>
List listOfStuffFiltered = Optional.ofNullable(listOfStuff)
.orElseGet(Collections::emptyList)
.stream()
.filter(Objects::nonNull)
.collect(Collectors.toList());</p><p>Hibernate notes:
N+1 problem
<a href=https://stackoverflow.com/questions/32453989/what-is-the-solution-for-the-n1-issue-in-jpa-and-hibernate>https://stackoverflow.com/questions/32453989/what-is-the-solution-for-the-n1-issue-in-jpa-and-hibernate</a></p><p>The query fetch N times</p><p>Root cause: Lazy loading
Fix: Eager fetch, can be explicitly declared in JPA query</p><p>e.g.
&ldquo;from Manufacturer manufacturer join fetch manufacturer.contact contact&rdquo;</p><p>SQL Injection</p><p>Solution:</p><ol><li>Prepared Statements</li><li>Parameterized Queries</li></ol><p>Spring Transaction
@Transactional
-> spring creates proxies for all the classes annotation with @Transactional, either on class or on any of the methods
-> proxy allows spring to inject transactional around the method (to start/commit the transaction)</p><p>Isolation Level
DEFAULT (default)
READ_UNCOMMITTED - Oracle not supported
READ_COMMITTED - Default for Oracle, Postgre, SQL Server
REPEATABLE_READ - MySQL default, Oracle not supported
SERIALIZABLE - highest level of isolation, prevents all concurrency side effects, but lowest concurrent access rate as it executes concurrent calls sequentially.</p><p>Oralcle isolation level
Read committed (Default) - every query executed by a transaction sees only data commited before the query began
Serializable - transaction sees only changes committed at the time transaction begin and changes made by transaction itself
Read-only -</p><p>Propagation Level
REQUIRED (default) - transaction 1 and transaction 2 will be under same transaction
REQUIRES_NEW - transaction 2 executes in a new transaction, outer transaction is suspended
NESTED - uses a single physical transaction with multiple savepoints that it can roll back to.</p><p>JPA Locking
<a href=https://hackernoon.com/optimistic-and-pessimistic-locking-in-jpa>https://hackernoon.com/optimistic-and-pessimistic-locking-in-jpa</a>
<a href=https://stackoverflow.com/questions/58786195/what-is-the-relation-between-spring-transactional-and-spring-lock-annotation>https://stackoverflow.com/questions/58786195/what-is-the-relation-between-spring-transactional-and-spring-lock-annotation</a>
<a href=https://www.baeldung.com/java-jpa-transaction-locks>https://www.baeldung.com/java-jpa-transaction-locks</a></p><p>Optimistic locking:</p><ul><li>the transaction doesn&rsquo;t lock the entity immediately. Instead, the transaction commonly saves the entity&rsquo;s state with a version number assigned to it.</li><li>@Version</li><li>if the entity is changed, the version number is increased by 1 (or timestamp updated)</li><li>When save, if original version does not match the version in DB, throw exception</li><li>Version number does not change When change @OneToMany and @ManyToMany collections with mappedBy attribute</li></ul><p>Pessimistic locking:</p><ul><li>when using perssimistic lock in a transaction and access an entity, entity will be locked immediately. Lock will be released by commit/rollback the transaction.</li><li>table rows are locked at DB level.</li><li>PESSIMISTIC_READ</li><li>PESSIMISTIC_WRITE</li><li>PESSIMISTIC_FORCE_INCREMENT</li></ul><p>2 types of locks:
Shared lock:
If someone holds a shared lock, we can read but cannot write in data. If want to modify/delete reserved data, need to obtain exclusive lock.</p><p>Exclusive lock:
can be obtained using &ldquo;SELECT &mldr; FOR UPDATE&rdquo; statements</p><h2 id=hibernate-1st-level-cache-vs-2nd-level-cache>Hibernate 1st level cache vs 2nd level cache
<a class=anchor href=#hibernate-1st-level-cache-vs-2nd-level-cache>#</a></h2><ul><li><p><a href=https://www.java67.com/2017/10/difference-between-first-level-and-second-level-cache-in-Hibernate.html>https://www.java67.com/2017/10/difference-between-first-level-and-second-level-cache-in-Hibernate.html</a></p></li><li><p>1st level cache - Session level (EntityManager level), always enabled and cannot disable</p></li><li><p>2nd level cache - SessionFactory level (EntityManagerFactory level), disabled by default</p></li><li><p>1st level cache is bounded to the current executing thread, so the cached entities cannot be shared by multiple concurrent requests.</p></li><li><p>2nd level cache is designed to be used by multiple concurrent requests.</p></li><li><p>Sequence:</p><ul><li>DefaultLoadEventListener -> load from session cache (1st level) -> not found, load from 2nd level cache -> load from DB</li></ul></li></ul><h2 id=rxjava>RxJava
<a class=anchor href=#rxjava>#</a></h2><ul><li><a href=https://code.tutsplus.com/tutorials/concurrency-in-rxjava-2--cms-29288>https://code.tutsplus.com/tutorials/concurrency-in-rxjava-2--cms-29288</a></li><li>Schedulers - used to execute a unit of work on a thread.</li><li>subscribeOn(Schedulers.io) - tell observable which schedule to use to push emission</li><li>observeOn() - to tell what thread the consumer will use to receive the emissions</li></ul><h3 id=how-to-handle-back-pressure>How to handle back pressure
<a class=anchor href=#how-to-handle-back-pressure>#</a></h3><ul><li>Pull strategy - produces only send new request when Subscriber requests</li><li>Limited push strategy - publisher can only send a maximum amount of itesm to client at once</li><li>Canceling the data streaming when consumer cannot process more requests</li></ul><h3 id=rxjava-backpressured>RxJava BackPressured
<a class=anchor href=#rxjava-backpressured>#</a></h3><ul><li>observables emitting items faster than subscriber can consume</li><li>onBackPressureBuffer</li></ul><h2 id=deadlock-can-capture-threaddump>deadlock (can capture threaddump)
<a class=anchor href=#deadlock-can-capture-threaddump>#</a></h2><ul><li><p>since Java 1.8 can use jcmd</p></li><li><p>jcmd</p></li><li><p>jcmd $PID Thread.print</p></li><li><p>Unix</p></li><li><p>kill -3</p></li><li><p>spring-boot-actuator</p></li><li><p>expose thread dump endpoints</p></li><li><p>/actuator/threaddump</p></li></ul><h2 id=heapdump-can-use-to-check-memory-leak>Heapdump (can use to check memory leak)
<a class=anchor href=#heapdump-can-use-to-check-memory-leak>#</a></h2><ul><li><p>jcmd</p></li><li><p>jcmd GC.heap_dump</p></li><li><p>spring-boot-actuator</p></li><li><p>expose threa dump endpoints</p></li><li><p>/actuator/heapdump</p></li></ul><h2 id=memory-leak>Memory leak
<a class=anchor href=#memory-leak>#</a></h2><ul><li><p>when GC unable to remove the no longer use objects in heap</p><ul><li>static fields - will not be collected, so becareful when store large collections in static fields</li><li>singletons, try to use lazy load approach instead of eager load</li><li>unclosed resources</li><li>improper implement equals() and hashcode() methods<ul><li>supposed Map should not allow duplicate keys, if implement wrongly will be regarded as different keys</li></ul></li><li>Inner class - as inner class object implicity holds a reference to outer class object, make it unable to be GC.</li></ul></li><li><p>GC removes unreferenced objects periodically, but it never collects objects that are still being referenced</p></li><li><p>Symptoms</p><ul><li>heap size does not drop in APM tools (e.g. jvisualVM, AppDynamics etc)</li></ul></li></ul><p>Generics</p><ul><li>Parameterized Type</li><li>allows type to be a parameter of class / methods / and interfaces.</li><li>can create classes / methods which can be worked with different types</li><li>Bounded vs Unbounded generics<ul><li>Bound: &lt;? extends T> , &lt;? extends super T></li><li>Unbounded:</li></ul></li><li>Array does not support Generics</li></ul><h2 id=parallel-gc>Parallel GC
<a class=anchor href=#parallel-gc>#</a></h2><p><a href="https://www.informit.com/articles/article.aspx?p=2496621&seqNum=2">https://www.informit.com/articles/article.aspx?p=2496621&seqNum=2</a>
At the time when Parallel GC was introduced in HotSpot, only the young generation used a parallel stop-the-world collector.
Old generation collections used a single-threaded stop-the-world collector.</p><ul><li>Enhanced version of Parallel GC by adding multithreaded old generation collector to be used with a mutlithreaded young gen collector.</li><li>enabled by XX:+UseParallelOldGC</li></ul><h2 id=g1gc>G1GC
<a class=anchor href=#g1gc>#</a></h2><p><a href=https://www.oracle.com/technical-resources/articles/java/g1gc.html>https://www.oracle.com/technical-resources/articles/java/g1gc.html</a>
G1 - designed for application which require shorter GC pauses.
divides the heap into fixed-sized regions.</p><h3 id=g1gc-concepts>G1GC Concepts
<a class=anchor href=#g1gc-concepts>#</a></h3><ul><li><p>allocating objects to young gen, and promoting aged objects to old gen</p></li><li><p>finding live objects in old gen through concurrent (parallel) marking phase. (Marking phase is triggered when total Java heap occupancy exceeds default threshold)</p></li><li><p>recovering free memory by compacting live objects through parallel copying.</p></li><li><p>heap is divided into a number of equally sized regions. During Startup JVM will set the region size (1MB - 32MB).</p></li><li><p>goal is no more than 2048 regions.</p></li><li><p>eden / survivor / old gen are logical sets of these regions and are not continous</p></li><li><p>During young collections, G1GC adjust young gen (eden and survivor sizes) to meet soft real-time target.</p></li><li><p>During mixed collections, G1GC adjust number of old regions that are collected based on
a target number of mixed GC,
% of live objects in each region of heap
overall acceptable heap waste %</p></li><li><p>Compaction - reduces heap fragmentation by incremental parallel copy of live objects from one or more sets of regions (CSet) into differnt new regions.</p><ul><li>in order to reclaim as much heap space as possible.</li><li>while attempting not to exceed the pause time goal (garbage first)</li></ul></li><li><p>Use Remembered Sets (RSets) to track references into regions. Enable parallel and independent collection of regions. ()</p></li><li><p>After 1 conncurent marking cycle complete, G1GC switches from young GC to perform mixed GC.</p></li><li><p>In mixed GC, G1GC will optionally add some old regions to the set of eden and surviror regsions that will be collected.</p></li><li><p>After the G1GC collects a sufficient number of old regions (over multiple mixed GC), G1 back to perform young GC until next marking cycle complete.</p></li></ul><h3 id=marking-cycle>Marking Cycle:
<a class=anchor href=#marking-cycle>#</a></h3><ul><li>Initial mark phase -</li><li>Root region scanning phase - scan survivor regions, runs concurrently (not STW), complete before next STW young GC start.</li><li>Concurrent marking phase - find live objects across the entier heap, runs concurrently, can be interrupted by STW</li><li>Remark phase - STW collection, helps to complete the marking cycle.</li><li>Cleanup phase - STW operation of accounting RSets scrubbing. During accounting, G1GC identifiers completely free regions and mixed GC candidates.</li></ul><h2 id=comparator>Comparator
<a class=anchor href=#comparator>#</a></h2><ul><li><a href=https://javarevisited.blogspot.com/2021/09/comparator-comparing-thenComparing-example-java-.html#axzz7aTQbNjOI>https://javarevisited.blogspot.com/2021/09/comparator-comparing-thenComparing-example-java-.html#axzz7aTQbNjOI</a></li><li>Comparing vs thenComparing</li><li>Comparator.comparing(Function&lt;? super T, ? extends U) - accept a Function that extracts a comparator sort key from Type T, return Comparator</li><li>Comparator.thenComparing&lt;Comparator&lt;? super T> comparator> - accepts a comparator, and return another compator</li></ul><p>e.g.
listOfBooks.sort(Comparator.comparing((Book b) -> b.getAuthor()));
same as
listOfBooks.sort(Comparator.comparing(Book::getAuthor));</p><p>if we need to add more compare criteria, e.g. price</p><h2 id=project-loom-java-19>Project Loom (Java 19)
<a class=anchor href=#project-loom-java-19>#</a></h2><p><a href="https://www.youtube.com/watch?v=_fRN7tpLyPk">https://www.youtube.com/watch?v=_fRN7tpLyPk</a></p><ul><li>2 types of concurrency<ul><li>Competitive: all threads compete for the CPUs/cores</li><li>Cooperative: each thread hand of the CPUs to the next</li></ul></li><li>loom implementation does both<ul><li>OS schedule carrier threads to CPU/cores</li><li>JDK codes schedule virtual threads to carrier threads</li></ul></li><li>Most virtual threads scheduling codes are written in Java in JDK (jdk.internal.vm.Continuation)</li><li>those written in C in JVM<ul><li>copy of the stack frames back and forth</li><li>GCs modified to find references in stack on heap (virtual thread context stores in heap, a stack on heap)</li></ul></li><li>there are cases not working, native codes in C<ul><li>sometimes virtual threads are pinned to their carrier thread</li><li>synchronized block<ul><li>written in assembly, uses an address on the stack, stack frames cannot be copied</li><li>so will stick to the same virtual threads</li></ul></li><li>so prefer to use ReentrantLock over synchronized()</li></ul></li><li>ThreadLocals<ul><li>basically hashMap</li><li>too heavy for virtual threads (imagine 1M virtual threads, will have 1M of hashMaps, which seems bad)</li><li>in virtual thread, has new concept, ExtentLocal / ScopedLocal</li></ul></li><li>Structured Concurrency<ul><li>already</li></ul></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#java-always-pass-by-value>Java always pass-by-value</a></li><li><a href=#break-vs-continue>break vs continue</a></li><li><a href=#serialization-vs-deserialization>Serialization vs deserialization</a></li><li><a href=#private-constructor>Private constructor</a></li><li><a href=#reflection>Reflection</a></li><li><a href=#unmodifiable-vs-immutable>Unmodifiable vs Immutable</a></li><li><a href=#how-to-create-immutable-class>How to create immutable class:</a></li><li><a href=#final-keyword>final keyword:</a></li><li><a href=#static-keyword>Static keyword:</a></li><li><a href=#static-nested-class-vs-inner-class-non-static>Static Nested class vs Inner Class (non static)</a></li><li><a href=#java-enumerations>Java Enumerations</a></li><li><a href=#thread-vs-executor>Thread vs Executor</a></li><li><a href=#executorservice-java6-vs-forkjoin-pool-java7>ExecutorService (Java6) vs Fork/Join Pool (Java7)</a></li><li><a href=#recursiveaction-vs-recursivetask-for-forjoinpool>RecursiveAction vs RecursiveTask (for ForJoinPool)</a></li><li><a href=#thread-states>Thread states</a></li><li><a href=#intrinsic-lock-monitor-lock-vs-extrinsic-lock>intrinsic lock (monitor lock) vs extrinsic lock</a><ul><li><a href=#intrinsic-lock>Intrinsic lock:</a></li><li><a href=#extrinsic-lock>Extrinsic lock:</a></li></ul></li><li><a href=#reentrantlock>ReentrantLock</a></li><li><a href=#lock-vs-synchronized>Lock vs Synchronized</a><ul><li><a href=#synchronzied>Synchronzied</a></li><li><a href=#lock>lock</a></li></ul></li><li><a href=#lock-implementations>Lock implementations</a><ul><li><a href=#trylock-does-not-work-with-wait--notify--notifyall><code>tryLock()</code> DOES NOT work with wait() / notify() / notifyAll()</a></li><li><a href=#countdownlatch>CountDownLatch</a></li><li><a href=#cyclicbarrier>CyclicBarrier</a></li><li><a href=#semaphore>Semaphore</a></li></ul></li><li><a href=#volatile-vs-atomic>Volatile vs Atomic</a></li><li><a href=#type-of-class-loaders>Type of class loaders</a></li><li><a href=#hashcode>hashCode()</a></li><li><a href=#data-structure-bigo>Data structure BigO</a></li><li><a href=#treemap>TreeMap:</a></li><li><a href=#queue-fifo>Queue FIFO:</a></li><li><a href=#stack-lifo>Stack LIFO:</a></li><li><a href=#completablefuture-vs-future>CompletableFuture vs Future</a></li><li><a href=#functionalinterface>FunctionalInterface</a></li><li><a href=#abstract-class-vs-interface>Abstract class vs Interface</a></li><li><a href=#polymophism-means-many-forms>Polymophism means &ldquo;many forms&rdquo;</a></li><li><a href=#method-overloading>Method overloading:</a></li><li><a href=#method-overriding>Method overriding:</a></li><li><a href=#aop>AOP</a></li><li><a href=#spring-order>Spring Order</a></li><li><a href=#jvm-heap-vs-non-heap>JVM Heap vs Non-heap</a></li><li><a href=#hibernate-1st-level-cache-vs-2nd-level-cache>Hibernate 1st level cache vs 2nd level cache</a></li><li><a href=#rxjava>RxJava</a><ul><li><a href=#how-to-handle-back-pressure>How to handle back pressure</a></li><li><a href=#rxjava-backpressured>RxJava BackPressured</a></li></ul></li><li><a href=#deadlock-can-capture-threaddump>deadlock (can capture threaddump)</a></li><li><a href=#heapdump-can-use-to-check-memory-leak>Heapdump (can use to check memory leak)</a></li><li><a href=#memory-leak>Memory leak</a></li><li><a href=#parallel-gc>Parallel GC</a></li><li><a href=#g1gc>G1GC</a><ul><li><a href=#g1gc-concepts>G1GC Concepts</a></li><li><a href=#marking-cycle>Marking Cycle:</a></li></ul></li><li><a href=#comparator>Comparator</a></li><li><a href=#project-loom-java-19>Project Loom (Java 19)</a></li></ul></nav></div></aside></main></body></html>